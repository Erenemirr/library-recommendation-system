import { Book, ReadingList, Review, Recommendation } from '@/types';
import { fetchAuthSession } from 'aws-amplify/auth';

/**
 * ============================================================================
 * API SERVICE LAYER - BACKEND COMMUNICATION
 * ============================================================================
 *
 * Åžu anda:
 * - Books ve Reading Lists iÃ§in gerÃ§ek AWS API Gateway + Lambda kullanÄ±yoruz
 * - DiÄŸer ÅŸeyler (reviews, recommendations, admin book iÅŸlemleri) ÅŸimdilik mock
 *
 * .env dosyanda:
 * VITE_API_BASE_URL=https://4b1qfbrpxj.execute-api.us-east-1.amazonaws.com/dev
 * ÅŸeklinde ayarlÄ± olmalÄ±.
 * ============================================================================
 */

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

// Åžimdilik Cognito yok, o yÃ¼zden sabit userId kullanÄ±yoruz
const CURRENT_USER_ID = '1';

async function parseApiJson<T>(response: Response): Promise<T> {
  const data = await response.json();

  if (typeof data === 'string') {
    return JSON.parse(data) as T;
  }

  if (data && typeof data === 'object' && 'body' in data) {
    const body = (data as { body: unknown }).body;
    if (typeof body === 'string') {
      return JSON.parse(body) as T;
    }
    return body as T;
  }

  return data as T;
}

async function getAuthHeaders(): Promise<Record<string, string>> {
  try {
    const session = await fetchAuthSession();
    const token = session.tokens?.idToken?.toString();
    if (!token) {
      return { 'Content-Type': 'application/json' };
    }
    return {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
  } catch {
    return { 'Content-Type': 'application/json' };
  }
}

function extractJsonBlock(text: string): unknown | null {
  const fencedMatch = text.match(/```json([\s\S]*?)```/i);
  if (fencedMatch) {
    try {
      return JSON.parse(fencedMatch[1]);
    } catch {
      return null;
    }
  }

  const arrayMatch = text.match(/\[[\s\S]*\]/);
  if (arrayMatch) {
    try {
      return JSON.parse(arrayMatch[0]);
    } catch {
      return null;
    }
  }

  const objectMatch = text.match(/\{[\s\S]*\}/);
  if (objectMatch) {
    try {
      return JSON.parse(objectMatch[0]);
    } catch {
      return null;
    }
  }

  return null;
}

function normalizeRecommendations(payload: unknown): Recommendation[] {
  const build = (items: unknown[]): Recommendation[] => {
    const mapped: Array<Recommendation | null> = items.map((item, index) => {
      if (!item || typeof item !== 'object') {
        return null;
      }
      const data = item as {
        id?: string | number;
        bookId?: string;
        title?: string;
        author?: string;
        reason?: string;
        confidence?: number;
      };
      return {
        id: String(data.id ?? `rec-${Date.now()}-${index}`),
        bookId: data.bookId ?? '',
        title: data.title,
        author: data.author,
        reason: data.reason ?? 'Recommendation generated by AI.',
        confidence: typeof data.confidence === 'number' ? data.confidence : 0.7,
      };
    });

    return mapped.filter((rec): rec is Recommendation => rec !== null);
  };

  if (Array.isArray(payload)) {
    return build(payload);
  }

  if (payload && typeof payload === 'object') {
    if ('recommendations' in payload && Array.isArray((payload as { recommendations?: unknown }).recommendations)) {
      return build((payload as { recommendations: unknown[] }).recommendations);
    }

    if ('raw' in payload) {
      const raw = (payload as { raw?: unknown }).raw;
      let text = '';
      if (typeof raw === 'string') {
        text = raw;
      } else if (raw && typeof raw === 'object' && 'content' in raw) {
        const content = (raw as { content?: Array<{ text?: string }> }).content;
        text = Array.isArray(content) ? content.map((c) => c.text || '').join('\n') : '';
      }

      const parsed = text ? extractJsonBlock(text) : null;
      if (parsed) {
        return normalizeRecommendations(parsed);
      }

      if (text) {
        return [
          {
            id: `rec-${Date.now()}-0`,
            bookId: '',
            reason: text,
            confidence: 0.7,
          },
        ];
      }
    }
  }

  return [];
}

/**
 * BOOKS
 * ============================================================================
 */

// TÃ¼m kitaplarÄ± getir
export async function getBooks(): Promise<Book[]> {
  const response = await fetch(`${API_BASE_URL}/books`);

  if (!response.ok) {
    throw new Error('Failed to fetch books');
  }

  const data = await parseApiJson<unknown>(response);
  if (Array.isArray(data)) {
    return data as Book[];
  }
  if (data && typeof data === 'object' && 'Items' in data) {
    return (data as { Items: Book[] }).Items;
  }
  if (data && typeof data === 'object' && 'books' in data) {
    return (data as { books: Book[] }).books;
  }
  return [];
}

// Tek bir kitabÄ± ID ile getir
export async function getBook(id: string): Promise<Book | null> {
  const response = await fetch(`${API_BASE_URL}/books/${id}`);

  if (response.status === 404) {
    return null;
  }

  if (!response.ok) {
    throw new Error('Failed to fetch book');
  }

  return parseApiJson<Book | null>(response);
}

/**
 * AÅŸaÄŸÄ±daki book create/update/delete fonksiyonlarÄ±
 * henÃ¼z gerÃ§ek backendâ€™e baÄŸlÄ± deÄŸil. Week 3â€“4â€™te
 * bunlar iÃ§in de Lambda + API Gateway eklenecek.
 */

// Yeni kitap oluÅŸtur (ÅŸimdilik sadece fake dÃ¶nÃ¼yor)
export async function createBook(book: Omit<Book, 'id'>): Promise<Book> {
  return new Promise((resolve) => {
    setTimeout(() => {
      const newBook: Book = {
        ...book,
        id: Date.now().toString(),
      };
      resolve(newBook);
    }, 500);
  });
}

// Kitap gÃ¼ncelle (ÅŸimdilik sadece local fake)
export async function updateBook(id: string, book: Partial<Book>): Promise<Book> {
  return new Promise((resolve) => {
    setTimeout(() => {
      const updatedBook: Book = {
        // GerÃ§ekte buraya mevcut kitabÄ± ekleyip merge etmen gerekir
        ...(book as Book),
        id,
      };
      resolve(updatedBook);
    }, 500);
  });
}

// Kitap sil (ÅŸimdilik no-op)
export async function deleteBook(): Promise<void> {
  return new Promise((resolve) => {
    setTimeout(() => resolve(), 300);
  });
}

/**
 * RECOMMENDATIONS (Bedrock) â€“ Week 4â€™te gerÃ§ek olacak
 * Åžimdilik tamamen mock.
 */

export async function getRecommendations(query: string): Promise<Recommendation[]> {
  const headers = await getAuthHeaders();
  const response = await fetch(`${API_BASE_URL}/recommendations`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ query }),
  });

  if (!response.ok) {
    throw new Error('Failed to get recommendations');
  }

  const data = await parseApiJson<unknown>(response);
  return normalizeRecommendations(data);
}

/**
 * READING LISTS
 * ============================================================================
 * Buradan sonrasÄ± tamamen senin yaptÄ±ÄŸÄ±n Lambdaâ€™lara baÄŸlÄ± ðŸŒŸ
 * Endpoints:
 *  - GET    /reading-lists?userId=1
 *  - POST   /reading-lists
 *  - PUT    /reading-lists/{id}
 *  - DELETE /reading-lists/{id}
 */

// KullanÄ±cÄ±nÄ±n bÃ¼tÃ¼n reading listelerini getir
export async function getReadingLists(): Promise<ReadingList[]> {
  const headers = await getAuthHeaders();
  const response = await fetch(`${API_BASE_URL}/reading-lists?userId=${CURRENT_USER_ID}`, {
    headers,
  });

  if (!response.ok) {
    throw new Error('Failed to fetch reading lists');
  }

  const data = await parseApiJson<unknown>(response);
  if (Array.isArray(data)) {
    return data as ReadingList[];
  }
  if (data && typeof data === 'object' && 'Items' in data) {
    return (data as { Items: ReadingList[] }).Items;
  }
  if (data && typeof data === 'object' && 'readingLists' in data) {
    return (data as { readingLists: ReadingList[] }).readingLists;
  }
  return [];
}

// Yeni reading list oluÅŸtur
export async function createReadingList(
  list: Omit<ReadingList, 'id' | 'createdAt' | 'updatedAt'>
): Promise<ReadingList> {
  const payload = {
    ...list,
    userId: CURRENT_USER_ID,
  };

  const headers = await getAuthHeaders();
  const response = await fetch(`${API_BASE_URL}/reading-lists`, {
    method: 'POST',
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    throw new Error('Failed to create reading list');
  }

  return parseApiJson<ReadingList>(response);
}

// Reading list gÃ¼ncelle
export async function updateReadingList(
  id: string,
  list: Partial<ReadingList>
): Promise<ReadingList> {
  const payload = {
    ...list,
    userId: CURRENT_USER_ID,
  };

  const headers = await getAuthHeaders();
  const response = await fetch(`${API_BASE_URL}/reading-lists/${id}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    throw new Error('Failed to update reading list');
  }

  return parseApiJson<ReadingList>(response);
}

// Reading list sil
export async function deleteReadingList(id: string): Promise<void> {
  const payload = {
    userId: CURRENT_USER_ID,
  };

  const headers = await getAuthHeaders();
  const response = await fetch(`${API_BASE_URL}/reading-lists/${id}`, {
    method: 'DELETE',
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok && response.status !== 204) {
    throw new Error('Failed to delete reading list');
  }

  // 204 No Content ise zaten body yok, direk return
}

/**
 * REVIEWS â€“ henÃ¼z backend yok, mock
 */

export async function getReviews(bookId: string): Promise<Review[]> {
  return new Promise((resolve) => {
    setTimeout(() => {
      const mockReviews: Review[] = [
        {
          id: '1',
          bookId,
          userId: '1',
          rating: 5,
          comment: 'Absolutely loved this book! A must-read.',
          createdAt: '2024-11-01T10:00:00Z',
        },
      ];
      resolve(mockReviews);
    }, 500);
  });
}

export async function createReview(review: Omit<Review, 'id' | 'createdAt'>): Promise<Review> {
  return new Promise((resolve) => {
    setTimeout(() => {
      const newReview: Review = {
        ...review,
        id: Date.now().toString(),
        createdAt: new Date().toISOString(),
      };
      resolve(newReview);
    }, 500);
  });
}
